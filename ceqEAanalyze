#! /usr/local/bin/perl

use Math::Complex;

$ERROR_BITDEPTH = (1 << 19);
$ERROR_BITDEPTH2 = (1 << 16);

sub round {
	my($val) = @_;
	if ($val >= 0) { $val += 0.5; }
	else { $val -= 0.5; }
	return int($val);
}

sub hex2dec {
	my ($val) = @_;

	while ($val =~ /^(.*)(0[Xx][\da-fA-F]+)(.*)$/) {
		my ($pre, $hex, $post) = ($1, $2, $3);
		if ($hex =~ /0[Xx][\da-fA-F]{6}/) {			# CoefData
			$VAL1_0 = 0x00800000;
			$VAL_POS_MAX = 0x80000000;
		} else {
			$VAL1_0 = 0x8000;
			$VAL_POS_MAX = 0x8000;
		}
		my $dec;
		if (eval($hex) >= $VAL_POS_MAX) {
			$dec = (eval($hex) - $VAL_POS_MAX * 2) / $VAL1_0;
		} else {
			$dec = eval($hex) / $VAL1_0;
		}
		$val = $pre . $dec . $post;
	}
	$val =~ s/<</*2**/g;
	$val =~ s/>>/*2**-/g;
	return eval($val);
}

sub tan { sin($_[0]) / cos($_[0]); }

if (($#ARGV != 5) && ($#ARGV != 7)) {
	my $cmd = `basename $0`;
	chomp $cmd;
	print "usage: $cmd a0 a1 a2 b1 b2 Fs\n";
	print " --+-|>---(+)------+--\n";
	print "   | a0  // \\\\     |  \n";
	print "   +-|>-+/   \\+-<|-+  \n";
	print "   | a1 /     \\ b1 |  \n";
	print "   +-|>+       +<|-+  \n";
	print "     a2         b2    \n";
	print "\n\n";
	print "usage: $cmd a0 a1 a2 b1 b2 m0 m1 Fs\n";
	print "   +------------------|>-+\n";
	print "   |                  m0  \\\n";
	print " --+-|>---(+)------+--|>--(+)--\n";
	print "   | a0  // \\\\     |  m1 \n";
	print "   +-|>-+/   \\+-<|-+  \n";
	print "   | a1 /     \\ b1 |  \n";
	print "   +-|>+       +<|-+  \n";
	print "     a2         b2    \n";
	exit 1;
}

if ($#ARGV == 7) {
	$eb_alg = 1;
}

$a0 = shift;
$a1 = shift;
$a2 = shift;
$b1 = shift;
$b2 = shift;
if ($eb_alg) {
	$m0 = shift;
	$m1 = shift;
}
$Fs = eval(shift);

$a0 = ($a0 =~ /0[Xx]/) ? hex2dec($a0) : eval($a0);
$a1 = ($a1 =~ /0[Xx]/) ? hex2dec($a1) : eval($a1);
$a2 = ($a2 =~ /0[Xx]/) ? hex2dec($a2) : eval($a2);
$b1 = ($b1 =~ /0[Xx]/) ? hex2dec($b1) : eval($b1);
$b2 = ($b2 =~ /0[Xx]/) ? hex2dec($b2) : eval($b2);

if ($eb_alg) {
	$m0 = ($m0 =~ /0[Xx]/) ? hex2dec($m0) : eval($m0);
	$m1 = ($m1 =~ /0[Xx]/) ? hex2dec($m1) : eval($m1);

	$a0 = $m0 + $a0 * $m1;
	$a1 = -$m0 * $b1 + $a1 * $m1;
	$a2 = -$m0 * $b2 + $a2 * $m1;

	print "a0 as EA --> $a0\n";
	print "a1 as EA --> $a1\n";
	print "a2 as EA --> $a2\n";
	print "b1 as EA --> $b1\n";
	print "b2 as EA --> $b2\n";
}

#print "plot 20*log10(abs(H_EA_N(z(x), $a0, $a1, $a2) / H_EA_D(z(x), $b1, $b2)))\n";
#print "plot sin(t), cos(t) notitle with lines, \\\nreal(pole1($b1,$b2)), imag(pole1($b1,$b2)), \\\nreal(pole2($b1,$b2)), imag(pole2($b1,$b2)), \\\n";
#print "real(zero1($a0,$a1,$a2)), imag(zero1($a0,$a1,$a2)), \\\nreal(zero2($a0,$a1,$a2)), imag(zero2($a0,$a1,$a2))\n";


$pi = 4 * atan2(1, 1);


$mag_dc      = (1 - $b1 - $b2 != 0) ? (($a0 + $a1 + $a2) / (1 - $b1 - $b2)) : "infinite";
$mag_nyquist = (1 + $b1 - $b2 != 0) ? ($a0 - $a1 + $a2) / (1 + $b1 - $b2) : "infinite";
$mag_cutoff  = (1 + $b2 != 0) ? ($a0 - $a2) / (1 + $b2) : "infinite";
$gain_dc      = ($mag_dc      eq "infinite") ? "infinite" : ($mag_dc      != 0) ? 20 * log(abs($mag_dc)) / log(10) : "-infinite";
$gain_nyquist = ($mag_nyquist eq "infinite") ? "infinite" : ($mag_nyquist != 0) ? 20 * log(abs($mag_nyquist)) / log(10) : "-infinite";
$gain_cutoff  = ($mag_cutoff  eq "infinite") ? "infinite" : ($mag_cutoff  != 0) ? 20 * log(abs($mag_cutoff)) / log(10) : "-infinite";

$pole1 = ($b1 + sqrt(cplx($b1**2 + 4*$b2, 0))) / 2;
$pole2 = ($b1 - sqrt(cplx($b1**2 + 4*$b2, 0))) / 2;
$zero1 = ($a0 != 0) ? (-$a1 + sqrt(cplx($a1**2 - 4*$a0*$a2, 0))) / (2*$a0) : (($a1 != 0) ? (-$a2 / $a1) : 0);
$zero2 = ($a0 != 0) ? (-$a1 - sqrt(cplx($a1**2 - 4*$a0*$a2, 0))) / (2*$a0) : (($a1 != 0) ? (-$a2 / $a1) : 0);

#printf "pole1 (%8.5f, %8.5f), pole2 (%8.5f, %8.5f) / zero1 (%8.5f, %8.5f), zero2 (%8.5f, %8.5f)\n", 
#	Re($pole1), Im($pole1), Re($pole2), Im($pole2), Re($zero1), Im($zero1), Re($zero2), Im($zero2);

#printf "pole1 arg(%7.2f, %9.2fHz), pole2 (%7.2f, %9.2fHz) / zero1 (%7.2f, %9.2fHz), zero2 (%7.2f, %9.2fHz)\n", 
#	180 * arg($pole1) / $pi, $Fs / 2 * arg($pole1) / $pi, 180 * arg($pole2) / $pi, $Fs / 2 * arg($pole2) / $pi, 
#	180 * arg($zero1) / $pi, $Fs / 2 * arg($zero1) / $pi, 180 * arg($zero2) / $pi, $Fs / 2 * arg($zero2) / $pi;


if ((abs($pole1) > 1) || (abs($pole2) > 1)) {
    print "pole is out of unit circle. this filter will be unstable!\n";
    exit 1;
}

$w0_2 = (1 + $b1 - $b2 != 0) ? (1 - $b1 - $b2) / (1 + $b1 - $b2) : 0;
if ($w0_2 >= 0) {
    $w0 = sqrt($w0_2);
} else {
    print "cannot proceed calculation, this coefficients were not calculated with \"bilinear arithmetic\"\n";
    exit 1;
}
    
$freq_d = (1 + $b1 - $b2 != 0) ? atan2($w0, 1) / $pi * $Fs : $Fs;	# reverse prewarping

$q_a = ($b2 != -1) ? sqrt((1 - $b1 - $b2) * (1 + $b1 - $b2)) / (2 * $b2 + 2) : "infinite";
#$q_a = -$b1 * $w0 / ((2 + $b1) * $w0_2 - 2 + $b1);
$q_d = (($freq_d != 0) && ($q_a ne "infinite")) ? $q_a * $Fs * tan($pi * $freq_d / $Fs) / ($freq_d * $pi) : "infinite";	# reverse prewarping


if      (($a0 == $a2) && (round(-$a1 * $ERROR_BITDEPTH) == round(2 * $a0 * $ERROR_BITDEPTH))) {	# HPF
	print "HPF\n";
	printf "	freq         --> %9.2f (Hz) ($freq_d)\n", $freq_d;
	printf "	q            --> %9.2f      ($q_d)\n", $q_d;
	printf "	q (as analog)--> %9.2f      ($q_a)\n", $q_a;
	printf "	gain_nyquist --> %9.2f (dB) ($gain_nyquist)\n", $gain_nyquist;
} elsif (($a0 == $a2) && (round( $a1 * $ERROR_BITDEPTH) == round(2 * $a0 * $ERROR_BITDEPTH))) {	# LPF
	print "LPF\n";
	printf "	freq         --> %9.2f (Hz) ($freq_d)\n", $freq_d;
	printf "	q            --> %9.2f      ($q_d)\n", $q_d;
	printf "	q (as analog)--> %9.2f      ($q_a)\n", $q_a;
	printf "	gain_dc      --> %9.2f (dB) ($gain_dc)\n", $gain_dc;
} elsif (round(($b1 * $a0 + $a1 - $a1 * $b2 + $b1 * $a2) * $ERROR_BITDEPTH) == 0) {	# PKG | BPF | APF
	if ($a1 == 0) {
		print "BPF\n";
		printf "	freq         --> %9.2f (Hz) ($freq_d)\n", $freq_d;
		printf "	q            --> %9.2f      ($q_d)\n", $q_d;
		printf "	q (as analog)--> %9.2f      ($q_a)\n", $q_a;
		printf "	cutoff gain  --> %9.2f (dB) ($gain_cutoff)\n", $gain_cutoff;
	} elsif (round(($a1 * (1 + $b2) -$b1 * ($a0 - $a2)) * $ERROR_BITDEPTH) == 0) {
		print "APF\n";
		printf "	freq         --> %9.2f (Hz) ($freq_d)\n", $freq_d;
		printf "	q            --> %9.2f      ($q_d)\n", $q_d;
		printf "	q (as analog)--> %9.2f      ($q_a)\n", $q_a;
		printf "	gain_dc      --> %9.2f (dB) ($gain_dc)\n", $gain_dc;
		printf "	gain_nyquist --> %9.2f (dB) ($gain_nyquist)\n", $gain_nyquist;
	} else {
		if ($b1 == 0) {
			"not proper coefficient (b1 == 0)\n";
			last;
		}
		print "PKG\n";
		my $mag_pkg = -$b1 * ($a0 - $a2) / ($a1 * (1 + $b2));
		my $gain_pkg   = ($mag_pkg    != 0) ? 20 * log(abs($mag_pkg)) / log(10) : "-infinite";

#		print "mag_pkg --> $mag_pkg, q_d --> $q_d\n";
		if (abs($mag_pkg) < 1) {
			$q_d = $q_d / abs($mag_pkg);
		}

		printf "	freq         --> %9.2f (Hz) ($freq_d)\n", $freq_d;
		printf "	q            --> %9.2f      ($q_d)\n", $q_d;
		printf "	gain_pass    --> %9.2f (dB) ($gain_dc)\n", $gain_dc;
		printf "	gain as pkg  --> %9.2f (dB) ($gain_pkg)\n", $gain_pkg;

		printf "	gain_dc      --> %9.2f (dB) ($gain_dc)\n", $gain_dc;
		printf "	gain_nyquist --> %9.2f (dB) ($gain_nyquist)\n", $gain_nyquist;
	}
} elsif (($a2 == 0) && ($b2 == 0)) {	# 1st order filter
	exec ("ceqFAanalyze $a0 $a1 $b1 $Fs");
} elsif (round($mag_dc * $mag_nyquist * $ERROR_BITDEPTH) == round($mag_cutoff * $mag_cutoff * $ERROR_BITDEPTH)) {
	my $freq1 = $freq_d / $mag_cutoff;
	my $freq2 = $freq_d * $mag_cutoff;
	my $freq_low  = ($freq1 < $freq2) ? $freq1 : $freq2;
	my $freq_high = ($freq1 < $freq2) ? $freq2 : $freq1;

	print "2nd Order Shelving Filter\n";
	printf "	freq_low     --> %9.2f (Hz) ($freq_low)\n", $freq_low;
	printf "	freq_center  --> %9.2f (Hz) ($freq_d)\n", $freq_d;
	printf "	freq_high    --> %9.2f (Hz) ($freq_high)\n", $freq_high;
	printf "	gain_dc      --> %9.2f (dB) ($gain_dc)\n", $gain_dc;
	printf "	gain_nyquist --> %9.2f (dB) ($gain_nyquist)\n", $gain_nyquist;
	printf "	q            --> %9.2f      ($q_d)\n", $q_d;
	printf "	q (as analog)--> %9.2f      ($q_a)\n", $q_a;
} else {
	print "complexed filter ...\n";
	printf "	freq         --> %9.2f (Hz) ($freq_d)\n", $freq_d;
	printf "	q            --> %9.2f      ($q_d)\n", $q_d;
	printf "\n";
	printf "as HPF ...\n";
	printf "	gain_nyquist --> %9.2f (dB) ($gain_nyquist)\n", $gain_nyquist;
	printf "as BPF ...\n";
	printf "	cutoff gain  --> %9.2f (dB) ($gain_cutoff)\n", $gain_cutoff;
	if (($a1 * (1 + $b2)) != 0) {
		my $mag_pkg = -$b1 * ($a0 - $a2) / ($a1 * (1 + $b2));
		if ($mag_pkg < 1) {
			my $q_neg = $q_d / abs($mag_pkg);
			printf "	q as cut     --> %9.2f (dB) ($q_neg)\n", $q_neg;
		}
	}
	printf "as LPF ...\n";
	printf "	gain_dc      --> %9.2f (dB) ($gain_dc)\n", $gain_dc;
}

