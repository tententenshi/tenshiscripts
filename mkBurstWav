#! /usr/bin/env perl

use strict;
use FindBin;
use POSIX;

require $FindBin::RealBin . "/wav_util.pm";


my $HEAD_LEADER = 1.0;	# 1.0 sec



sub usage {
	my $cmd = `basename $0`;
	chomp $cmd;
	print "usage: $cmd Osc_Freq[Hz] Magnitude[max=1.0] Wave_Counts[no unit] Interval[sec] Wave_Length[sec] [FORMAT_ID=3] [FS=44100] [NUM_OF_CH=1] [BIT_LENGTH=32] [ENDIAN=LITTLE] outWavFile\n";
	exit 1;
}

sub Round {
	my ($val) = @_;
	return floor($val + 0.5);
}


#
# main
#
{
	my %infoHash;
	$infoHash{ "FORMAT_ID" } =  3;	# Float
	$infoHash{ "NUM_OF_CH" } =  1;	# Number of Channels
	$infoHash{ "FS" } = 	    44100;	# Sampling Rate
	$infoHash{ "BIT_LENGTH" } = 32;
	$infoHash{ "BLOCK_SIZE" } = $infoHash{ "BIT_LENGTH" } / 8 * $infoHash{ "NUM_OF_CH" };
	$infoHash{ "DATA_RATE" } =  $infoHash{ "BLOCK_SIZE" } * $infoHash{ "FS" };

	my $convert_endian = 0;
	my $out_filename = "";

	my $Osc_Freq = eval(shift);
	my $Magnitude = eval(shift);
	my $Wave_Counts = eval(shift);
	my $Interval = eval(shift);
	my $Wave_Length = eval(shift);
	while (my $str = shift) {
		if ($str =~ /FORMAT_ID=(.+)/) {
			$infoHash{ "FORMAT_ID" } = eval($1);
		} elsif ($str =~ /FS=(.+)/) {
			$infoHash{ "FS" } = eval($1);
		} elsif ($str =~ /NUM_OF_CH=(.+)/) {
			$infoHash{ "NUM_OF_CH" } = eval($1);
		} elsif ($str =~ /BIT_LENGTH=(.+)/) {
			$infoHash{ "BIT_LENGTH" } = eval($1);
		} elsif ($str =~ /ENDIAN=(.+)/) {
			if ($1 =~ /BIG/) {
				$convert_endian = 1;
			} else {
				$convert_endian = 0;
			}
		} else {
			$out_filename = $str;
		}
	}
	if ($out_filename eq "") {
		usage();
	}

	my $fhOut;
	open($fhOut, "> $out_filename") or die "cannot open $out_filename!\n";
	wav_util::WriteWavHeader($fhOut);

	$infoHash{ "BLOCK_SIZE" } = $infoHash{ "BIT_LENGTH" } / 8 * $infoHash{ "NUM_OF_CH" };
	$infoHash{ "DATA_RATE" } =  $infoHash{ "BLOCK_SIZE" } * $infoHash{ "FS" };


	my $wav_size = 0;

	for (my $time = 0; $time <= $HEAD_LEADER * $infoHash{ "FS" }; $time++) {
		if ($infoHash{ "NUM_OF_CH" } == 1) {
			wav_util::WriteWavData($fhOut, \%infoHash, (0));
		} elsif ($infoHash{ "NUM_OF_CH" } == 2) {
			wav_util::WriteWavData($fhOut, \%infoHash, (0, 0));
		}
		$wav_size += $infoHash{ "BLOCK_SIZE" };
	}

	my $PI = 4 * atan2(1,1);
	my $phase = 0;
	my $Interval_Sample = $Interval * $infoHash{ "FS" };
	my $Cur_Interval_Goal = $Interval_Sample;
	my $Wave_Length_Sample = $Wave_Length * $infoHash{ "FS" };

	for (my $Cur_Sample = 0; $Cur_Sample < $Wave_Length_Sample; $Cur_Sample++) {
		$phase = $phase + $Osc_Freq / $infoHash{ "FS" };
		my $sine_wave = sin(2 * $phase * $PI);

		if ($phase > $Wave_Counts) {
			$sine_wave = 0;
		}

		if ($Cur_Sample > $Cur_Interval_Goal) {
			$phase = 0;
			$Cur_Interval_Goal += $Interval_Sample;
		}
#		print "Cur_Sample:$Cur_Sample, phase:$phase, sine_wave:$sine_wave, Cur_Interval_Goal:$Cur_Interval_Goal\n";
		if ($infoHash{ "NUM_OF_CH" } == 1) {
			wav_util::WriteWavData($fhOut, \%infoHash, ($sine_wave * $Magnitude));
		} elsif ($infoHash{ "NUM_OF_CH" } == 2) {
			wav_util::WriteWavData($fhOut, \%infoHash, ($sine_wave * $Magnitude, $sine_wave * $Magnitude));
		}
		$wav_size += $infoHash{ "BLOCK_SIZE" };
	}

	close(IN);
	close($fhOut);

	wav_util::MaintainWavHeader($out_filename, \%infoHash, $wav_size);
}
